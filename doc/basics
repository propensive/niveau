## Quick Start

A schema may be implemented as a singleton object extending `Schema[T]`, where `T` is the fixed
type that each field will return. Additionally, the object should also define the method `fields`,
returning a `List[String]` of the valid field names for record instances of that schema. Whichever
string values this method returns when the code to construct a record is invoked (at compiletime)
will be considered valid field names for that record.

Accordingly, different schemas must be implemented as different singletons.

Furthermore, an `apply` method should be implemented as a macro on the singleton object, exactly
as follows:
```scala
transparent inline def apply(inline fn: String => T): Record[T] = ${build('fn)}
```

Invoking this method will construct a new record, an instance of `Record[T]`, whose field values
will be obtained by calling the `fn` function with the field's name, as a `String`.

Here is a full, albeit uninteresting, example:
```scala
object Numbers extends Schema[Int]:
  def fields = List("one", "two", "three", "four")
  transparent inline def apply(inline fn: String => Int): Record[Int] = ${build('fn)}
```

The field names are defined in the source code, but they could be obtained from anywhere
(provided the code will produce the desired output when it is invoked inside the compiler at
compiletime).

In a different file, this `Numbers` schema object may be used to construct new `Record[Int]`
objects. These instances must be backed by some means of obtaining the field values, given a
field name; this is just a lambda, so the implementation is up to the programmer.

Here, we implement a record using a `Map[String, Int]`:
```scala
val numberMap = Map(
  "one"   -> 1,
  "two"   -> 2,
  "three" -> 3,
  "four"  -> 4,
  "five"  -> 5
)

val record = Numbers(numberMap)
```

Given the value, `record`, any fields defined in the `fields` method may be invoked on it, and
will return appropriate values from the map.

For example, `record.one` will return the `Int`, `1`. But `record.six` will be a compile error,
as will `record.five`: even though the runtime `numberMap` object contains a value for the
`String` `"five"`, the schema does not define it.

## Compilation Order

It is crucial that the schema singleton is defined in a different file from the invocation. This
is to guarantee that the object (and hence the fields it defines) is available as a runtime object
during later compilations which use it. Scala is able to compile a macro definition and its usage
in the correct order so long as they are defined in separate files (and no cyclic dependencies
exist between those files).

## Limitations

It is not currently possible for different fields to return different types.
